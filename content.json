{"meta":{"title":"ZEPHYRUS","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2021-04-20T10:41:11.000Z","updated":"2021-04-20T11:15:38.662Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-20T10:38:46.000Z","updated":"2021-04-20T11:15:49.082Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-04-20T10:41:03.000Z","updated":"2021-04-20T11:15:59.327Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-20T10:37:58.000Z","updated":"2021-04-20T11:16:04.907Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MPI点对点通信","slug":"MPI点对点通信","date":"2021-04-28T23:40:19.000Z","updated":"2021-04-28T23:44:15.697Z","comments":true,"path":"2021/04/29/MPI点对点通信/","link":"","permalink":"http://example.com/2021/04/29/MPI%E7%82%B9%E5%AF%B9%E7%82%B9%E9%80%9A%E4%BF%A1/","excerpt":"","text":"MPI点对点通信点对点通信机制： 阻塞(block)通信，发送方进程在调用send发送信息后一直处于阻塞状态，直到接收方进程调用recv开始接收信息；接收方进程在调用recv开始接收信息后处于阻塞状态，直到信息接收完成。 非阻塞(nonblock)通信，发送方进程在调用send发送信息后立即返回，可以进行其他操作；接收方在调用recv后要么得到信息，要么得到空值。 点对点通信模式（根据缓冲管理，发送与接受方的同步方式划分）： **同步通信模式(synchronous)**，在接收进程recv启动后，发送过程send才正确返回。 **缓冲通信模式(buffered)**，随时可以执行接收发送进程，需要提前申请缓冲区。通过MPI_Buffer_attach申请缓冲区，通过MPI_Buffer_detach回收缓冲区。 **标准通信模式(standard)**，是否对发送的数据进行缓冲由MPI的实现来决定， 不由用户程序控制。 **就绪通信模式(ready)**，发送操作只有在接收进程相应的接收操作已经开始才进行发送。当发送操作启动而相应的接收进程未启动，发送操作将出错。 就绪通信模式的特殊之处在于接收操作必须先于发送操作启动。 四种通信模式的调用函数如下： 通信模式 发送 接收 同步通信模式 MPI_SSEND MPI_RECV 缓冲通信模式 MPI_BSEBD MPI_RECV 标准通信模式 MPI_SEND MPI_RECV 就绪通信模式 MPI_RSEND MPI_RECV 标准通信模式举例1234567891011121314151617181920212223242526272829303132333435363738// 标准点对点通信 - 是否缓存数据由MPI自己决定#include &lt;mpi.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; MPI_Init(NULL, NULL); // get the rank and size int world_rank, world_size; MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); if (world_size != 2) &#123; fprintf(stderr, &quot;The process number must be 2~\\n&quot;); MPI_Abort(MPI_COMM_WORLD, 1); &#125; // process 0 send number if (world_rank == 0) &#123; int number_send = 2; MPI_Send(&amp;number_send, 1, MPI_INT, 1, 0, MPI_COMM_WORLD); printf(&quot;process %d send the number: %d to process 1\\n&quot;, world_rank, number_send); &#125; else &#123; int number_recv = 0; MPI_Recv(&amp;number_recv, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE); printf(&quot;process %d recv the number: %d from process 0\\n&quot;, world_rank, number_recv); &#125; // process 1 recv number MPI_Finalize(); return 0;&#125; 缓冲通信模式举例12345678910111213141516171819202122232425262728293031323334353637383940414243// 缓冲点对点通信 - 缓存数据由MPI自己决定#include &lt;mpi.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define BUFFER_SIZE 1024int main(int argc, char const *argv[])&#123; int *buffer; buffer = (void *)malloc(BUFFER_SIZE * sizeof(int)); MPI_Init(NULL, NULL); // get the rank and size int world_rank, world_size; MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); if (world_size != 2) &#123; fprintf(stderr, &quot;The process number must be 2~\\n&quot;); MPI_Abort(MPI_COMM_WORLD, 1); &#125; // process 0 send number and process 1 recv the number if (world_rank == 0) &#123; int number_send = 2; int buffer_size; MPI_Buffer_attach(buffer,BUFFER_SIZE*sizeof(int)); MPI_Bsend(&amp;number_send, 1, MPI_INT, 1, 0, MPI_COMM_WORLD); printf(&quot;process %d send the number: %d to process 1\\n&quot;, world_rank, number_send); MPI_Buffer_detach(buffer,&amp;buffer_size); &#125; else &#123; int number_recv = 0; MPI_Recv(&amp;number_recv, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE); printf(&quot;process %d recv the number: %d from process 0\\n&quot;, world_rank, number_recv); &#125; MPI_Finalize(); return 0;&#125; 同步通信模式举例1234567891011121314151617181920212223242526272829303132333435363738// 同步点对点通信 - 缓存数据由MPI自己决定#include &lt;mpi.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define BUFFER_SIZE 1024int main(int argc, char const *argv[])&#123; MPI_Init(NULL, NULL); // get the rank and size int world_rank, world_size; MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); if (world_size != 2) &#123; fprintf(stderr, &quot;The process number must be 2~\\n&quot;); MPI_Abort(MPI_COMM_WORLD, 1); &#125; // process 0 send number and process 1 recv the number if (world_rank == 0) &#123; int number_send = 2; MPI_Ssend(&amp;number_send, 1, MPI_INT, 1, 0, MPI_COMM_WORLD); printf(&quot;process %d send the number: %d to process 1\\n&quot;, world_rank, number_send); &#125; else &#123; int number_recv = 0; MPI_Recv(&amp;number_recv, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE); printf(&quot;process %d recv the number: %d from process 0\\n&quot;, world_rank, number_recv); &#125; MPI_Finalize(); return 0;&#125; 就绪通信模式举例1234567891011121314151617181920212223242526272829303132333435363738// 就绪点对点通信 - 缓存数据由MPI自己决定#include &lt;mpi.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define BUFFER_SIZE 1024int main(int argc, char const *argv[])&#123; MPI_Init(NULL, NULL); // get the rank and size int world_rank, world_size; MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); if (world_size != 2) &#123; fprintf(stderr, &quot;The process number must be 2~\\n&quot;); MPI_Abort(MPI_COMM_WORLD, 1); &#125; // process 0 send number and process 1 recv the number if (world_rank == 0) &#123; int number_send = 2; MPI_Rsend(&amp;number_send, 1, MPI_INT, 1, 0, MPI_COMM_WORLD); printf(&quot;process %d send the number: %d to process 1\\n&quot;, world_rank, number_send); &#125; else &#123; int number_recv = 0; MPI_Recv(&amp;number_recv, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE); printf(&quot;process %d recv the number: %d from process 0\\n&quot;, world_rank, number_recv); &#125; MPI_Finalize(); return 0;&#125;","categories":[{"name":"MPI编程","slug":"MPI编程","permalink":"http://example.com/categories/MPI%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"MPI编程","slug":"MPI编程","permalink":"http://example.com/tags/MPI%E7%BC%96%E7%A8%8B/"}],"author":"ZEPHYRUS"},{"title":"Hello World","slug":"hello-world","date":"2021-04-20T09:03:59.042Z","updated":"2021-04-20T09:03:59.042Z","comments":true,"path":"2021/04/20/hello-world/","link":"","permalink":"http://example.com/2021/04/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"MPI编程","slug":"MPI编程","permalink":"http://example.com/categories/MPI%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"MPI编程","slug":"MPI编程","permalink":"http://example.com/tags/MPI%E7%BC%96%E7%A8%8B/"}]}